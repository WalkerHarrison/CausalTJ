mie <- function(Z, S, Y, X, A, subset, thres = 1e-6, optim.method = "BFGS", max.step = 1000, singular.ok = TRUE, need.variance = TRUE) {
### 0. Checks arguments ###################################
## 0.1 Checks data type ###################################
if (!is.vector(Z)) stop("Z should be a vector.")
Z <- as.logical(Z)
if (!is.vector(S)) stop("S should be a vector.")
S <- as.logical(S)
if (!is.vector(Y)) stop("Y should be a vector.")
if (missing(X)) X <- NULL
else {
X <- as.matrix(X)
if (!is.matrix(X)) stop("X must be either a vector or a matrix.")
}
if (missing(A)) A <- NULL
else {
A <- as.matrix(A)
if (!is.matrix(A)) stop("A must be either a vector or a matrix.")
}
## 0.2 Length check ###################################
if (missing(subset)) { # check if Z,S,Y,A,X have same length
n <- length(Z)
if (length(S) != n) stop("S must have the same length as Z's.")
if (length(Y) != n) stop("Y must have the same length as Z's.")
if ((!is.null(X)) & (nrow(X) != n)) stop("X must have the same row number as Z's length.")
if ((!is.null(A)) & (nrow(A) != n)) stop("A must have the same row number as Z's length.")
}
## 0.3 Subset ##################################
else { # subset is provided
Z <- Z[subset]
S <- S[subset]
Y <- Y[subset]
if (!is.null(A)) A <- A[subset]
if (!is.null(X)) X <- X[subset,]
n <- length(Z)
}
## 0.4 Missing values ###############################
if (sum(is.na(Z))) stop("Z should not have missing values.")
if (sum(is.na(S))) stop("S should not have missing values.")
if (sum(is.na(Y[S]))) stop("Y should not have missing values where S==1.")
if ((!is.null(X)) & (sum(is.na(X)))) stop("X should not have missing values.")
if (is.null(A)) {
warning("A is not provided, naive method (OLS) is used.")
if (is.null(X)) return(lm(Y ~ Z, subset = S))
else return(lm(Y ~ Z + X, subset = S))
}
else { if (sum(is.na(A))) stop("A should not have missing values.") }
### 1. Sets up data ###########################
s1 = S == 1;
s0_z1 = S == 0 & Z == 1
s1_z0 = S == 1 & Z == 0;
s0_z0 = S == 0 & Z == 0
sz = cbind(s1, s0_z1, s1_z0, s0_z0)
W <- cbind(rep(1, n), X, A)
d <- ncol(W)
### 2. Defining interior functions ###########################################
expit <- function(x) exp(x) / (1 + exp(x))
nLL_beta <- function(beta, gamma, W, sz) {
ebeta = expit(W %*% beta)
egamma = expit(W %*% gamma)
loglike = sum(sz[, 1] * log(ebeta) + sz[, 2] * log(1 - ebeta) + sz[, 3] * log(egamma) + sz[, 4] * log(1 - ebeta * egamma))
return(loglike)
}
#nLL_gamma <- function(gamma, beta, W, sz) nLL_beta(beta, gamma, W, sz) # permute sequence of arguments
#beta.gr <- function(beta, gamma, W, sz) {
#ebeta = as.vector(expit(W %*% beta))
#egamma = as.vector(expit(W %*% gamma))
#loglike.partial.beta <- colSums((sz[, 1] * (1 - ebeta) + sz[, 2] * (-ebeta) + sz[, 4] /(1-ebeta * egamma) *(- egamma) *(ebeta)*(1-ebeta))* W)
#return (loglike.partial.beta)
#}
#gamma.gr <- function(gamma, beta, W, sz) {
#ebeta = as.vector(expit(W %*% beta))
#egamma = as.vector(expit(W %*% gamma))
#loglike.partial.gamma <- colSums((sz[, 3] * (1 - egamma) + sz[, 4] / (1 - ebeta * egamma) * (-ebeta) * (egamma) * (1 - egamma)) * W)
#return(loglike.partial.gamma)
#}
beta_gamma.gr <- function(beta, gamma, W, sz) {
ebeta = as.vector(expit(W %*% beta))
egamma = as.vector(expit(W %*% gamma))
loglike.partial.beta <- colSums((sz[, 1] * (1 - ebeta) + sz[, 2] * (-ebeta) + sz[, 4] / (1 - ebeta * egamma) * (-egamma) * (ebeta) * (1 - ebeta)) * W)
loglike.partial.gamma <- colSums((sz[, 3] * (1 - egamma) + sz[, 4] / (1 - ebeta * egamma) * (-ebeta) * (egamma) * (1 - egamma)) * W)
return (c(loglike.partial.beta,loglike.partial.gamma))
}
#beta.hessian <- function(beta, gamma, W, sz) {
#Wbeta <- as.vector(W %*% beta)
#ebeta = expit(Wbeta)
#egamma = as.vector(expit(W %*% gamma))
#d <- length(beta)
#loglike.hessian.beta <- matrix(rep(0, d ^ 2), nrow = d)
#for (i in 1:n) {
#loglike.hessian.beta <- loglike.hessian.beta - (sz[i, 1] + sz[i, 2] + sz[i, 4] * (1 + exp(2 * Wbeta[i]) * (-1 + egamma[i])) * egamma[i] / (-1 + exp(Wbeta[i]) * (-1 + egamma[i])) ^ 2) * (1 - ebeta[i]) * ebeta[i] * outer(W[i,], W[i,])
#}
#return(loglike.hessian.beta)
#}
#gamma.hessian <- function(gamma, beta, W, sz) {
#ebeta <- as.vector(expit(W %*% beta))
#Wgamma <- as.vector(W %*% gamma)
#egamma <- expit(Wgamma)
#d <- length(beta)
#loglike.hessian.gamma <- matrix(rep(0, d ^ 2), nrow = d)
#for (i in 1:n) {
#loglike.hessian.gamma <- loglike.hessian.gamma - (sz[i, 3] + sz[i, 4] * (1 + exp(2 * Wgamma[i]) * (-1 + ebeta[i])) * ebeta[i] / (-1 + exp(Wgamma[i]) * (-1 + ebeta[i])) ^ 2) * (1 - egamma[i]) * egamma[i] * outer(W[i,], W[i,])
#}
#return(loglike.hessian.gamma)
#}
#beta_gamma.hessian <- function(beta, gamma, W, sz) {
#Wbeta <- as.vector(W %*% beta)
#exp_Wbeta <- exp(Wbeta)
#Wgamma <- as.vector(W %*% gamma)
#exp_Wgamma <- exp(Wgamma)
#d <- length(beta)
#for (i in 1:n) {
#loglike.hessian.beta_gamma <- loglike.hessian.beta_gamma - sz[i, 4] * exp_Wbeta[i] * exp_Wgamma[i] / (1 + exp_Wbeta[i] + exp_Wgamma[i]) ^ 2 * outer(W[i,], W[i,])
#}
#return(loglike.hessian.beta_gamma)
#}
### 3. Parameter estimation ##############################################
## 3.1 Estimating $\beta$ and $\gamma$
#lm.s1_z1 <- glm(S~X+A,subset=Z==1,family=binomial)
#beta <- rep(0, d) #initial values
#gamma <- rep(0, d) #initial values
#Diff <- function(x, y) sum((x - y) ^ 2) / sum(x ^ 2 + thres) # normalized euclidean distance
#diff <- thres + 1
#step <- 0
#opt1 <- opt2 <- NULL
#while (diff > thres & step < max.step) {
#opt1 <- optim(beta, nLL_beta, gamma = gamma, W = W, sz = sz,
#method = optim.method,
#gr = beta.gr,
#hessian = TRUE,
#control = list(fnscale = -1, maxit = max.step))
#diff1 <- Diff(opt1$par, beta)
#beta <- opt1$par
#cat("loglik1:", nLL_beta(beta, gamma, W, sz), '\n')
#cat("loglik.partial.beta:", beta.gr(beta, gamma, W, sz), '\n')
#require(numDeriv)
#cat("loglik.partial.beta.numer:", grad(nLL_beta, beta, gamma = gamma, W = W, sz = sz),'\n')
#opt2 <- optim(gamma, nLL_gamma, beta = beta, W = W, sz = sz,
#method = optim.method,
#gr = gamma.gr,
#hessian = TRUE,
#control = list(fnscale = -1, maxit = max.step))
#diff <- max(diff1, Diff(opt2$par, gamma))
#gamma <- opt2$par
#cat("loglik2:", nLL_beta(beta, gamma, W, sz), '\n')
#cat("loglik.partial.gamma:", gamma.gr(gamma, beta, W, sz), '\n')
#cat("loglik.partial.gamma.numer:", grad(nLL_gamma, gamma,beta= beta, W = W, sz = sz,),'\n')
#step <- step + 1
#}
opt3 <- optim(c(rep(0, d), rep(0, d)),
function(beta_gamma, W, sz) nLL_beta(beta_gamma[1:d], beta_gamma[-(1:d)], W, sz),
W = W, sz = sz,
gr = function(beta_gamma, W, sz) beta_gamma.gr(beta_gamma[1:d], beta_gamma[-(1:d)], W, sz),
method = optim.method,
hessian = need.variance,
control = list(fnscale = -1, maxit = 2 * max.step))
if (opt3$convergence != 0) { warning(paste("Optimization of beta and gamma didn't converge in", max.step, "steps !")) }
beta <- opt3$par[1:d]
gamma <- opt3$par[-(1:d)]
#cat("opt3$beta:", beta, '\n')
#cat("opt3$gamma:", gamma, '\n')
#cat("loglik_3:", nLL_beta(beta,gamma , W, sz), '\n')
#cat("loglik.partial.beta:", beta.gr(beta, gamma, W, sz), '\n')
#cat("loglik.partial.beta.numer:", grad(nLL_beta, beta, gamma = gamma, W = W, sz = sz), '\n')
#cat("loklike_1:", opt1$value, "\n")
#cat("loglike_2:", opt2$value, "\n")
#cat("hessian_beta_formula:", '\n')
#print(beta.hessian(beta, gamma, W, sz))
#cat("hessian_beta_numer:", '\n')
##print(opt1$hessian)
#print(hessian(nLL_beta, beta, gamma = gamma, W = W, sz = sz))
#cat("hessian_gamma_formula:", '\n')
#print(gamma.hessian(gamma, beta, W, sz))
#cat("hessian_beta_gamma_formula:", '\n')
#print(beta_gamma.hessian(beta, gamma, W, sz))
#cat("hessian_beta_gamma_numer:", '\n')
#print(opt3$hessian)
## 3.2 Estimating alpha_0 (for Z==0) ################
if (is.null(X)) lm.y.z0 <- lm(Y ~ 1 + A, subset = Z == 0, singular.ok = singular.ok)
else lm.y.z0 <- lm(Y ~ 1 + X + A, subset = Z == 0, singular.ok = singular.ok)
alpha_0 <- lm.y.z0$coef
## 3.3 Estimating alpha_1 (for Z==1) ##################
#W.expit <- expit(W %*% gamma) # W.expit is the estimate of G
#if (is.null(X)) lm.y.z1 <- lm(Y ~ 1 + W.expit, subset = (Z == 1 & S == 1), singular.ok = singular.ok)
#else lm.y.z1 <- lm(Y ~ 1 + X + W.expit, subset = (Z == 1 & S == 1), singular.ok = singular.ok)
alpha_1.gamma <- function(gamma) {
W.expit <- expit(W %*% gamma) # W.expit is the estimate of G
if (is.null(X)) lm.y.z1 <- lm(Y ~ 1 + W.expit, subset = (Z == 1 & S == 1), singular.ok = singular.ok)
else lm.y.z1 <- lm(Y ~ 1 + X + W.expit, subset = (Z == 1 & S == 1), singular.ok = singular.ok)
return(lm.y.z1)
}
lm.y.z1<-alpha_1.gamma(gamma)
alpha_1 <- lm.y.z1$coef
#if (length(alpha_1) < d) alpha_1[d] <- 0
### 4. SACE estimation ###################################################
## 4.1 E[Y(0)|G=LL] \equiv sace_z0
#if (is.null(X)) mu_0_LL_W <- predict(lm.y.z0, data.frame(A = A))
#else mu_0_LL_W <- predict(lm.y.z0, data.frame(X = X, A = A)))
mu_0_LL.fun <- function(alpha_0.beta.gamma, W) {
alpha_0 <- alpha_0.beta.gamma[1:d]
beta <- alpha_0.beta.gamma[(d + 1):(2 * d)]
gamma <- alpha_0.beta.gamma[(2 * d + 1):(3 * d)]
mu_0_LL_W <- W %*% alpha_0 # n*1
LL_W <- expit(W %*% beta) * expit(W %*% gamma) #n*1
mu_0_LL <- sum(mu_0_LL_W * LL_W) / sum(LL_W) #scaler
return(mu_0_LL)
}
#LL_W <- expit(W %*% beta) * expit(W %*% gamma) #n*1
#mu_0_LL_W.var <- W %*% alpha_0.var %*% t(W) # n*n
#cat("mu_0_LL_W.var:", '\n')
#print(mu_0_LL_W.var)
#LL_W.grad <- ebeta * egamma * cbind(W * (1 - ebeta), W * (1 - egamma)) #n*2d
#LL_W.var <- LL_W.grad %*% beta_gamma.var %*% t(LL_W.grad) #n*n=(n*2d)%*%(2d*2d)%*%(2d*n)
#cat("LL_W.var:", '\n')
#print(LL_W.var)
mu_0_LL <- mu_0_LL.fun(c(alpha_0, beta, gamma), W)
## 4.2 E[Y(1)|G=LL] \equiv sace_z1
mu_1_LL.fun <- function(alpha_1.beta.gamma, W) {
alpha_1 <- alpha_1.beta.gamma[1:length(alpha_1)]
beta <- alpha_1.beta.gamma[(length(alpha_1) + 1):(length(alpha_1) + d)]
gamma <- alpha_1.beta.gamma[(length(alpha_1) + d + 1):(length(alpha_1) + 2 * d)]
Coef <- cbind(rep(1, n), X, rep(1, n))
mu_1_LL_W <- Coef %*% alpha_1 #n*1
LL_W <- expit(W %*% beta) * expit(W %*% gamma) #n*1
mu_1_LL <- sum(mu_1_LL_W * LL_W) / sum(LL_W) #scaler
return(mu_1_LL)
}
mu_1_LL <- mu_1_LL.fun(c(alpha_1, beta, gamma), W)
sace <- mu_1_LL - mu_0_LL
names(beta) <- names(alpha_0)
names(gamma) <- names(alpha_0)
results <- list(CALL = match.call(),
data = list(Z = Z, S = S, Y = Y, X = X, A = A), n = n,
optim.method = optim.method,
need.variance=need.variance,
mu_0_LL = mu_0_LL, mu_1_LL = mu_1_LL,
sace = sace,
beta = beta, gamma = gamma,
beta_gamma.convergence = opt3$convergence,
alpha_0 = alpha_0, alpha_1 = alpha_1)
if (need.variance) {
require(numDeriv)
beta_gamma.var <- try(solve(-opt3$hessian))
if ('try-error' %in% class(beta_gamma.var)) {
warning("Failed to estimate variance: Singular Hessian!")
results <- c(results, list(sace.var = Inf))
class(results) <- c("mie", "list")
return(results)
}
pos_definite <- try(prod(diag(beta_gamma.var) >= 0))
if ('try-error' %in% class(pos_definite) | is.na(pos_definite) | (!pos_definite)) {
warning("Failed to estimate variance: Non-positive definite Hessian!")
results <- c(results, list(sace.var = Inf))
class(results) <- c("mie", "list")
return(results)
}
beta.var <- beta_gamma.var[1:d, 1:d]
gamma.var <- beta_gamma.var[-(1:d), - (1:d)]
if ((P_value <- 2 * (1 - max(pnorm(abs(beta[d] / sqrt(beta.var[d, d]))), pnorm(abs(gamma[d] / sqrt(gamma.var[d, d])))))) > 0.10) {
warning(paste("Substitution variable(A) had insignificant effect on survival(S)! P Value =", P_value))
}
#print(beta_gamma.var)
#cat("beta.var:", '\n')
#print(beta.var)
#cat("gamma.var:", '\n')
#print(gamma.var)
alpha_0.var <- vcov(lm.y.z0)
alpha_1.var <- vcov(lm.y.z1)
# additonal variance of alpha_1 due to the randomness of W.expit
alpha_1.partial.gamma <- matrix(nrow = length(alpha_1), ncol = length(gamma))
for (i in 1:length(alpha_1)) {
alpha_1.partial.gamma[i,] <- grad(function(x)(alpha_1.gamma(x)$coef)[i], gamma)
}
alpha_1.var <- alpha_1.var + alpha_1.partial.gamma %*% gamma.var %*% t(alpha_1.partial.gamma)
mu_0_LL.grad <- try(grad(mu_0_LL.fun, c(alpha_0, beta, gamma), W = W))
if ('try-error' %in% class(mu_0_LL.grad)) {
warning("Failed to estimate variance!")
results <- c(results, list(sace.var = Inf))
class(results) <- c("mie", "list")
return(results)
}
#cat('mu_0_LL.grad:', '\n')
#print(mu_0_LL.grad)
mu_1_LL.grad <- try(grad(mu_1_LL.fun, c(alpha_1, beta, gamma), W = W))
if ('try-error' %in% class(mu_1_LL.grad)) {
warning("Failed to estimate variance!")
results <- c(results, list(sace.var = Inf))
class(results) <- c("mie", "list")
return(results)
}
alpha_0_alpha_1_beta_gamma.var <- matrix(rep(0, (3 * d + length(alpha_1)) ^ 2), nrow = 3 * d + length(alpha_1))
alpha_0_alpha_1_beta_gamma.var[1:d, 1:d] <- alpha_0.var
alpha_0_alpha_1_beta_gamma.var[(d + 1):(d + length(alpha_1)), (d + 1):(d + length(alpha_1))] <- alpha_1.var
alpha_0_alpha_1_beta_gamma.var[(d + length(alpha_1) + 1):(3 * d + length(alpha_1)), (d + length(alpha_1) + 1):(3 * d + length(alpha_1))] <- beta_gamma.var
mu_0_LL.var <- mu_0_LL.grad %*% alpha_0_alpha_1_beta_gamma.var[-((d + 1):(d + length(alpha_1))), - ((d + 1):(d + length(alpha_1)))] %*% mu_0_LL.grad
#cat('mu_0_LL.var:', '\n')
#print(mu_0_LL.var)
mu_1_LL.var <- mu_1_LL.grad %*% alpha_0_alpha_1_beta_gamma.var[-(1:d), - (1:d)] %*% mu_1_LL.grad
#cat('mu_1_LL.var:', '\n')
#print(mu_1_LL.var)
sace.grad <- rep(0, 3 * d + length(alpha_1))
sace.grad[1:d] <- (-1) * mu_0_LL.grad[1:d]
sace.grad[(d + 1):(d + length(alpha_1))] <- mu_1_LL.grad[1:length(alpha_1)]
sace.grad[(d + length(alpha_1) + 1):(3 * d + length(alpha_1))] <- mu_1_LL.grad[-(1:length(alpha_1))] - mu_0_LL.grad[-(1:d)]
sace.var <- sace.grad %*% alpha_0_alpha_1_beta_gamma.var %*% sace.grad
#cat('sace.var:', '\n')
#print(sace.var)
results <- c(results, list(beta.var = beta.var, gamma.var = gamma.var, alpha_0.var = alpha_0.var, alpha_1.var = alpha_1.var, mu_0_LL.var = mu_0_LL.var, mu_1_LL.var = mu_1_LL.var, sace.var = sace.var))
}
class(results) <- c("mie", "list")
return(results)
}
dat <- units.TJ %>% rbind(units.NOTJ) %>%
filter(!is.na(before), !is.nan(before), !is.nan(after))
View(dat)
dat <- dat %>% mutate(S = !is.na(after))
View(dat)
a <- mie(dat$TJ, dat$S, dat$after)
a <- mie(Z = dat$TJ, S = dat$S, Y = dat$after)
a <- mie(Z = dat$TJ, S = dat$S, Y = dat$after, X = NULL)
model.matrix(dat)
model.matrix(after ~ ., data = dat)
View(model.matrix(after ~ ., data = dat))
View(model.matrix(after ~ . - TJ - S, data = dat))
View(model.matrix(after ~ . - TJ - S - pitcher, data = dat))
X = model.matrix(after ~ . - TJ - S - pitcher, data = dat)
a <- mie(Z = dat$TJ, S = dat$S, Y = dat$after, X = X)
length(dat$TJ)
nrows(X)
nrow(X)
X = model.matrix(after ~ . - TJ - S - pitcher, data = dat)
X = model.matrix(S ~ . - TJ - pitcher, data = dat)
X = model.matrix(S ~ . - TJ - pitcher - after, data = dat)
X = model.matrix(height ~ weight, data = dat)
X = model.matrix(S ~ height, data = dat)
X = model.matrix(S ~ weight, data = dat)
X = model.matrix(S ~ age, data = dat)
summary(dat)
dat <- units.TJ %>% rbind(units.NOTJ) %>%
filter(!is.na(before), !is.na(after), !is.nan(before), !is.nan(after)) %>%
filter(!is.na(height))
summary(dat)
X = model.matrix(S ~ . - after, data = dat)
dat <- dat %>% mutate(S = !is.na(after))
X = model.matrix(S ~ . - after, data = dat)
summary(X %>% select(-after))
names(X)
summary(dat %>% select(-after))
X = model.matrix(S ~ . - after, data = dat)
X = model.matrix(S ~ height, data = dat)
View(dat)
dat <- units.TJ %>% rbind(units.NOTJ) %>%
filter(!is.na(before), !is.nan(before), !is.nan(after)) %>%
filter(!is.na(height))
dat <- dat %>% mutate(S = !is.na(after))
X = model.matrix(S ~ height, data = dat)
X = model.matrix(S ~ . - after, data = dat)
summary(dat)
X = model.matrix(S ~ . age, data = dat)
X = model.matrix(S ~ age, data = dat)
X = model.matrix(S ~ age + height + weight, data = dat)
X = model.matrix(S ~ age + height + weight + throws + pitches + starter, data = dat)
X = model.matrix(S ~ age + height + weight + throws + pitches + starter + before, data = dat)
a <- mie(Z = dat$TJ, S = dat$S, Y = dat$after, X = X)
a <- mie(Z = dat$TJ, S = dat$S, Y = dat$after, X = X, A == NULL)
a <- mie(Z = dat$TJ, S = dat$S, Y = dat$after, X = X, A = NULL)
a <- mie(Z = dat$TJ, S = dat$S, Y = dat$after, X = X, A = NULL)
dat <- units.TJ %>% rbind(units.NOTJ) %>%
filter(!is.na(before), !is.nan(before), !is.nan(after)) %>%
filter(!is.na(height))
dat <- dat %>% mutate(S = !is.na(after))
X = model.matrix(S ~ age + height + weight + throws + pitches + starter + before, data = dat)
Z = dat$TJ; S = dat$S; Y = dat$after; A = NULL
if (!is.vector(Z)) stop("Z should be a vector.")
Z <- as.logical(Z)
if (!is.vector(S)) stop("S should be a vector.")
S <- as.logical(S)
if (!is.vector(Y)) stop("Y should be a vector.")
if (missing(X)) X <- NULL
else {
X <- as.matrix(X)
if (!is.matrix(X)) stop("X must be either a vector or a matrix.")
}
if (missing(X)) X <- NULL
if (!is.vector(Z)) stop("Z should be a vector.")
Z <- as.logical(Z)
if (!is.vector(S)) stop("S should be a vector.")
S <- as.logical(S)
if (!is.vector(Y)) stop("Y should be a vector.")
if (missing(X)) X <- NULL
else {
X <- as.matrix(X)
if (!is.matrix(X)) stop("X must be either a vector or a matrix.")
}
if (missing(A)) A <- NULL
else {
A <- as.matrix(A)
if (!is.matrix(A)) stop("A must be either a vector or a matrix.")
}
Z = dat$TJ; S = dat$S; Y = dat$after; A = NULL
if (!is.vector(Z)) stop("Z should be a vector.")
Z <- as.logical(Z)
if (!is.vector(S)) stop("S should be a vector.")
S <- as.logical(S)
if (!is.vector(Y)) stop("Y should be a vector.")
if (missing(X)) X <- NULL
else {
X <- as.matrix(X)
if (!is.matrix(X)) stop("X must be either a vector or a matrix.")
}
if (missing(A)) A <- NULL
else {
A <- as.matrix(A)
if (!is.matrix(A)) stop("A must be either a vector or a matrix.")
}
a <- mie(Z = dat$TJ, S = dat$S, Y = dat$after, X = X)
Z = dat$TJ; S = dat$S; Y = dat$after; A = NULL
### 0. Checks arguments ###################################
## 0.1 Checks data type ###################################
if (!is.vector(Z)) stop("Z should be a vector.")
Z <- as.logical(Z)
if (!is.vector(S)) stop("S should be a vector.")
S <- as.logical(S)
if (!is.vector(Y)) stop("Y should be a vector.")
if (missing(X)) X <- NULL
else {
X <- as.matrix(X)
if (!is.matrix(X)) stop("X must be either a vector or a matrix.")
}
Z = dat$TJ; S = dat$S; Y = dat$after; A = NULL
if (sum(is.na(Z))) stop("Z should not have missing values.")
if (sum(is.na(S))) stop("S should not have missing values.")
if (sum(is.na(Y[S]))) stop("Y should not have missing values where S==1.")
if ((!is.null(X)) & (sum(is.na(X)))) stop("X should not have missing values.")
if (is.null(A)) {
warning("A is not provided, naive method (OLS) is used.")
if (is.null(X)) return(lm(Y ~ Z, subset = S))
else return(lm(Y ~ Z + X, subset = S))
}
b<- lm(after ~ before, data = dat)
resid(b)
##### fake data
Z <- c(1, 1, 1, 0, 0, 0)
G <- c('LL', 'LD', 'DD', 'LL', 'LD', 'DD')
prop.zg <- rep(1/6, 6)
S <- c(1, 1, 0, 1, 0, 0)
Y <- c(5, 3, NA, 4, NA, NA)
prop.azg <- c(2/3, 1/3, 1/2, 2/3, 1/3, 1/2)
A2 <- data.frame(Z, G, prop.zg, S, Y, prop.azg)
A2
A2 %>% group_by(Z,S) %>%
summarize(sum(prop.zg))
A2 %>% group_by(Z,S) %>%
summarize(sum(prop.zg), sum(Y))
A2 %>% group_by(Z,S) %>%
summarize(sum(prop.zg), sum(prop.azg*Y))
A2 %>% group_by(Z,S) %>%
summarize(sum(prop.zg), mean(Y))
A2 %>% group_by(Z,S) %>%
summarize(sum(prop.zg), mean(Y), sum(prop.azg))
A2 %>% group_by(Z,S) %>% arrange(desc(Z), desc(S)) %>%
summarize(sum(prop.zg), mean(Y), sum(prop.azg))
A2 %>% group_by(Z,S) %>%
summarize(sum(prop.zg), mean(Y), sum(prop.azg)) %>%
arrange(desc(Z), desc(S))
A2 %>% group_by(Z,S) %>%
summarize(sum(prop.zg), mean(Y), mean(prop.azg)) %>%
arrange(desc(Z), desc(S))
5/12
A2 %>% group_by(Z,S) %>%
summarize(prop.zs = sum(prop.zg),
Y = mean(Y),
prop.azs = mean(prop.azg)) %>%
arrange(desc(Z), desc(S))
B2 <- A2 %>% group_by(Z,S) %>%
summarize(prop.zs = sum(prop.zg),
Y = mean(Y),
prop.azs = mean(prop.azg)) %>%
arrange(desc(Z), desc(S))
A2
B2
names(pitches.full4)
load("/Users/walkerharrison/Dropbox/Causal2018/pitches/pitches11.Rdata")
names(pitches11)
head(pitches)
head(pitches11)
setwd('/Users/walkerharrison/Desktop/Baseball Papers/Data')
#load('pitches/pitches08.Rdata')
#load('pitches/pitches09.Rdata')
#load('pitches/pitches10.Rdata')
#load('pitches/pitches11.Rdata')
load('pitches/pitches12.Rdata')
load('pitches/pitches13.Rdata')
load('pitches/pitches14.Rdata')
load('pitches/pitches15.Rdata')
load('pitches/pitches16.Rdata')
load('pitches/pitches17.Rdata')
load('pitches/pitches18.Rdata')
names(pitches11)
names(pitches18)
rm(pitches11)
rm(pitches12)
rm(pitches13)
rm(pitches14)
rm(pitches15)
rm(pitches16)
rm(pitches17)
rm(pitches18)
pitches.TJ <- pitches.full4 %>%
filter(!is.na(surgery_date)) %>%
group_by(pitcher) %>%
filter(surgery_date > min(datetime))
str(pitches.full4)
